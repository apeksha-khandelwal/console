#!/bin/sh

set -e -u -o pipefail

if [ $# -eq 0 ]; then
    echo "The first argument must be a path to a directory of kubeconfigs"
    exit 1
fi

KUBECONFIGS_DIR=$1
KUBECTL="kubectl --kubeconfig kubeconfig"
CLUSTERS=
CLUSTER_IPS=
BOOTSTRAP=
ETCD_CLUSTER_TOKEN=
ETCD_INITIAL_CLUSTER=
FEDERATION_TOKEN=
FEDERATION_URL=

# Gather kubeconfigs and convert to json
for f in $KUBECONFIGS_DIR/*; do
    [ ! -f "$f" ] && continue
    mv $f $f.yaml
    mkdir -p $f
    kubectl --kubeconfig $f.yaml config view --flatten -o json > $f/kubeconfig
    rm $f.yaml
done

# Find clusters
for d in $KUBECONFIGS_DIR/*; do
    [ ! -d "$d" ] && continue
    [ "$(basename $d)" = "federation" ] && continue
    CLUSTERS="$CLUSTERS $(basename $d)"
done

# Set the bootstrap cluster
BOOTSTRAP=$(echo $CLUSTERS | cut -d " " -f 1)

# Merge kubeconfigs
for cluster in $CLUSTERS; do
    $KUBECTL config set-cluster $cluster

    $KUBECTL config set clusters.${cluster}.server \
        "$(jq -r '.clusters[0].cluster.server' $KUBECONFIGS_DIR/${cluster}/kubeconfig)"

    $KUBECTL config set clusters.${cluster}.certificate-authority-data \
        "$(jq -r '.clusters[0].cluster."certificate-authority-data"' $KUBECONFIGS_DIR/${cluster}/kubeconfig)"

    $KUBECTL config set-credentials $cluster

    $KUBECTL config set users.${cluster}.client-certificate-data \
        "$(jq -r '.users[0].user."client-certificate-data"' $KUBECONFIGS_DIR/${cluster}/kubeconfig)"

    $KUBECTL config set users.${cluster}.client-key-data \
        "$(jq -r '.users[0].user."client-key-data"' $KUBECONFIGS_DIR/${cluster}/kubeconfig)"

    $KUBECTL config set-context $cluster \
        --cluster=${cluster} \
        --user=${cluster}
done

# Create federation kubeconfig
FEDERATION_URL="$(jq -r '.clusters[0].cluster.server' $KUBECONFIGS_DIR/$BOOTSTRAP/kubeconfig | sed 's/-api\././g')/federation-api"
# Get the federation token
$KUBECTL config use-context $BOOTSTRAP
if ! $KUBECTL describe secrets federation-apiserver-secrets -n federation > /dev/null 2>&1 ; then
    FEDERATION_TOKEN=$(head -c 16 /dev/urandom | od -An -t x | tr -d ' ')
else
    FEDERATION_TOKEN=$($KUBECTL get secret federation-apiserver-secrets -n federation -o go-template='{{index .data "known-tokens.csv"}}' | base64 --decode | cut -d "," -f 1)
fi
$KUBECTL config set-cluster federation \
    --server="$FEDERATION_URL" \
    --insecure-skip-tls-verify=true
$KUBECTL config set-credentials federation \
    --token="$FEDERATION_TOKEN"
$KUBECTL config set-context federation \
    --cluster=federation \
    --user=federation
$KUBECTL config use-context federation
mkdir -p "$KUBECONFIGS_DIR"/federation
$KUBECTL config view --flatten --minify > "$KUBECONFIGS_DIR"/federation/kubeconfig

for cluster in $CLUSTERS; do
    $KUBECTL config use-context $cluster

    # Create federation namespace
    $KUBECTL apply -f manifests/federation-namespace.yaml
    
    # Create cluster role binding
    $KUBECTL apply -f manifests/federation-cluster-role-binding.yaml
done

# Set etcd values
ETCD_CLUSTER_TOKEN=$(head -c 16 /dev/urandom | od -An -t x | tr -d ' ')
for cluster in $CLUSTERS; do
    u=$(jq -r '.clusters[0].cluster.server' $KUBECONFIGS_DIR/${cluster}/kubeconfig)
    ip="$(dig +short $(echo $u | sed 's|https\{0,1\}://||g' | cut -d ":" -f 1) | head -n 1)"
    CLUSTER_IPS="$CLUSTER_IPS $ip"
    [ ! -z $ETCD_INITIAL_CLUSTER ] && ETCD_INITIAL_CLUSTER="$ETCD_INITIAL_CLUSTER,"
    ETCD_INITIAL_CLUSTER="$ETCD_INITIAL_CLUSTER$cluster=http://$ip:32380"
done

# Create federation etcd configmap, deployment, and service
i=1
for cluster in $CLUSTERS; do
    $KUBECTL config use-context $cluster
    if ! $KUBECTL describe configmap federation-etcd -n federation > /dev/null 2>&1 ; then
        $KUBECTL create configmap federation-etcd \
            -n federation \
            --from-literal=initial-cluster=$ETCD_INITIAL_CLUSTER \
            --from-literal=cluster-token=$ETCD_CLUSTER_TOKEN \
            --from-literal=member-name=$cluster \
            --from-literal=member-ip=$(echo $CLUSTER_IPS | awk "{print \$$i}")
    fi
    $KUBECTL apply -f manifests/federation-etcd-deployment.yaml
    $KUBECTL apply -f manifests/federation-etcd-service.yaml
    i=$((i+1))
done

create_apiserver_secret() {
    # Create federation apiserver secret
    if ! $KUBECTL describe secrets federation-apiserver-secrets -n federation > /dev/null 2>&1 ; then
        $KUBECTL create secret generic federation-apiserver-secrets \
            --from-literal="known-tokens.csv=$FEDERATION_TOKEN,admin,admin"\
            -n federation
    fi
}
 
# Create federation apiserver resources
create_apiserver_ingress_and_configmap() {
    # Create federation apiserver service
    $KUBECTL apply -f manifests/federation-apiserver-service.yaml

    # Create federation apiserver ingress
    local cluster_url=$(jq -r '.clusters[0].cluster.server' $KUBECONFIGS_DIR/$1/kubeconfig | sed 's/-api\././g')
    local cluster_domain=$(echo $cluster_url | sed 's|https\{0,1\}://||g' | cut -d ":" -f 1)
    cat > manifests/federation-apiserver-ingress.yaml <<EOF
apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  annotations:
    ingress.kubernetes.io/rewrite-target: /
    ingress.kubernetes.io/secure-backends: "true"
    kubernetes.io/ingress.class: tectonic
  name: federation-apiserver
  namespace: federation
spec:
  tls:
  - hosts:
    - $cluster_domain
    secretName: tectonic-ingress-tls-secret
  rules:
  - host: $cluster_domain
    http:
      paths:
      - backend:
          serviceName: federation-apiserver
          servicePort: 443
        path: /federation-api
EOF
    $KUBECTL apply -f manifests/federation-apiserver-ingress.yaml

    # Create federation apiserver configmap
    if ! $KUBECTL describe configmap federation-apiserver -n federation > /dev/null 2>&1 ; then
        $KUBECTL create configmap federation-apiserver \
            -n federation \
            --from-literal=advertise-address="$( \
                $KUBECTL get service federation-apiserver \
                -n federation -o jsonpath='{.spec.clusterIP}')" \
            --from-literal=etcd-address="$( \
                $KUBECTL get service federation-etcd \
                -n federation -o jsonpath='{.spec.clusterIP}')"
    fi
}
   
# Create kubeconfig secrets
create_kubeconfig_secrets() {
    # Create federation kubeconfig secret
    if ! $KUBECTL describe secret federation-apiserver-kubeconfig -n federation > /dev/null 2>&1 ; then
        $KUBECTL create secret generic federation-apiserver-kubeconfig \
            --from-file="$KUBECONFIGS_DIR"/federation/kubeconfig \
            -n federation
    fi
    
    # Create cluster kubeconfig secrets
    for cluster in ${CLUSTERS}; do
        if ! $KUBECTL describe secret ${cluster} -n federation > /dev/null 2>&1 ; then
            $KUBECTL create secret generic ${cluster} \
                --from-file=$KUBECONFIGS_DIR/${cluster}/kubeconfig \
                -n federation
        fi
    done
}

# Create federation controller manager resources
create_controller_manager_resources() {
    # Create federation controller manager configmap
    if ! $KUBECTL describe configmap federation-controller-manager -n federation > /dev/null 2>&1 ; then
        $KUBECTL create configmap federation-controller-manager \
            --from-literal=zone-id=${DNS_ZONE_ID} \
            --from-literal=zone-name=${DNS_ZONE_NAME} \
            -n federation
    fi
    
    # Create federation controller manager deployment
    $KUBECTL apply -f manifests/federation-controller-manager-deployment.yaml
}

$KUBECTL config use-context $BOOTSTRAP
create_apiserver_secret
create_apiserver_ingress_and_configmap $BOOTSTRAP

# Create federation apiserver daemonset
$KUBECTL apply -f manifests/federation-apiserver-daemonset.yaml

# Wait for federation bootstrap apiserver to become available
$KUBECTL config use-context federation
until $KUBECTL get clusters >/dev/null 2>&1; do
    printf "waiting for bootstrap federation apiserver to become available at %s\n" "$FEDERATION_URL"
    sleep 5
done

$KUBECTL config use-context $BOOTSTRAP
create_kubeconfig_secrets
create_controller_manager_resources

# Create cluster resources
mkdir -p clusters
for cluster in ${CLUSTERS}; do
    cat > clusters/${cluster}.yaml <<EOF
apiVersion: federation/v1beta1
kind: Cluster
metadata:
  name: ${cluster}
  annotations:
    federation.alpha.coreos.com/console: "$(jq -r '.clusters[0].cluster.server' $KUBECONFIGS_DIR/${cluster}/kubeconfig | sed 's/-api\././g')"
spec:
  serverAddressByClientCIDRs:
    - clientCIDR: "0.0.0.0/0"
      serverAddress: "$(jq -r '.clusters[0].cluster.server' $KUBECONFIGS_DIR/${cluster}/kubeconfig)"
  secretRef:
    name: ${cluster}
EOF
done

$KUBECTL config use-context federation
$KUBECTL apply -f clusters --validate=false

# Pivot
for cluster in $CLUSTERS; do
    $KUBECTL config use-context $cluster
    create_apiserver_ingress_and_configmap $cluster
    $KUBECTL apply -f manifests/federation-cluster-role-binding.yaml
done
$KUBECTL config use-context federation
$KUBECTL apply -f manifests/federation-namespace.yaml
create_apiserver_secret
$KUBECTL apply -f manifests/federation-apiserver-daemonset.yaml
create_kubeconfig_secrets
create_controller_manager_resources
 
printf "Run the following commands in the JavaScript console in the Tectonic Console to enable the cluster picker:\n"
printf "localStorage.setItem('federation-apiserver-token', '%s');\n" "$FEDERATION_TOKEN"
printf "localStorage.setItem('federation-apiserver-url', '%s');\n" "$FEDERATION_URL"
